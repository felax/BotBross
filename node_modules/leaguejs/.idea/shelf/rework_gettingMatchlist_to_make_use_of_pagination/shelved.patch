Index: .editorconfig
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .editorconfig	(revision )
+++ .editorconfig	(revision )
@@ -0,0 +1,8 @@
+[*]
+charset=utf-8
+end_of_line=lf
+insert_final_newline=false
+indent_style=tab
+tab_width=4
+trim_trailing_whitespace=true
+max_line_length=120
\ No newline at end of file
Index: lib/util/MatchUtil.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const ErrorUtil = require('./ErrorUtil');\nclass MatchUtil {\n\t/**\n\t *\n\t * @param {string} gameVersion Versioning string from MatchDto.gameVersion\n\t * @param {string[]} versions Array with valid ddragon version {@link StaticDataEndpoint.gettingVersions}\n\t * @return {string} The data dragon version correlating to the gameVersion\n\t */\n\tstatic getVersionForGameVersion(gameVersion, versions) {\n\t\tlet gameVersionMajorMinor = MatchUtil.getPatchFromGameVersion(gameVersion);\n\n\t\tlet ddVersion = versions.find(version => {\n\t\t\treturn version.indexOf(gameVersionMajorMinor + '.') === 0;\n\t\t});\n\n\t\tif (!ddVersion) {\n\t\t\tconsole.log('Version could not be matched, using latest version ' + versions[0]);\n\t\t\tddVersion = versions[0];\n\t\t}\n\t\tconsole.log(`MatchUtil.getVersionForGameVersion() version is resolved: ${ddVersion} gameVersion: ${gameVersion} majorMinor: ${gameVersionMajorMinor}`);\n\t\treturn ddVersion;\n\t}\n\n\t/**\n\t *\n\t * @param {string} gameVersion Versioning string from MatchDto.gameVersion\n\t * @return {string} The major.minor versioning string\n\t */\n\tstatic getPatchFromGameVersion(gameVersion) {\n\t\tconst numDots = (gameVersion.match(/\\./g) || []).length;\n\n\t\tif (numDots === 1){\n\t\t\t// already major.minor\n\t\t\treturn gameVersion;\n\t\t} else {\n\t\t\tlet indexFirstDot = gameVersion.indexOf('.');\n\t\t\tlet indexSecondDot = gameVersion.substr(indexFirstDot + 1).indexOf('.') + indexFirstDot + 1;\n\t\t\treturn gameVersion.substr(0, indexSecondDot);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Object} param\n\t * @param {MatchDto} param.matchDto\n\t * @param {number} param.accountId\n\t * @param [param.useCurrentOnly = true] if false, currentAccountId and accountId will be used for comparisson.\n\t * Useful if the player is likely to have transfered between regions recently.\n\t * @return {ParticipantIdentityDto | undefined} undefined if participant could not be found\n\t */\n\tstatic getParticipantIdentityByAccountId({matchDto, accountId, useCurrentOnly = true}) {\n\t\t// since accountId is only unique per region, we default to the safe comparisson of currentAccountId\n\n\t\tconst participants = matchDto.participantIdentities.map(identity => identity.player);\n\t\treturn participants.find(participant => {\n\t\t\tconst isEqualOnCurrentInfo = participant.currentAccountId === accountId;\n\t\t\treturn isEqualOnCurrentInfo || useCurrentOnly ? isEqualOnCurrentInfo : participant.accountId === accountId;\n\t\t});\n\t}\n\n\t/**\n\t * @param {Object} param\n\t * @param param.accountId\n\t * @param param.platformId\n\t * @param param.matchDto\n\t * @return {ParticipantIdentityDto | undefined} undefined if participant could not be found\n\t */\n\tstatic getParticipantIdentityByAccountAndPlatformId({ matchDto, accountId, platformId}){\n\t\tErrorUtil.throwIfNotObject(matchDto, 'matchDto');\n\t\tErrorUtil.throwIfNotNumerical(accountId, 'accountId');\n\t\tErrorUtil.throwIfNotString(platformId, 'platformId');\n\t\tconst participantIdentityDto = matchDto.participantIdentities.find(({player}) => {\n\t\t\tconst isEqualOnCurrentInfo =\n\t\t\t\tplayer.currentAccountId === accountId && player.currentPlatformId === platformId.toUpperCase();\n\t\t\t// since accountId is unique per region, we can always compare current and old information safely\n\t\t\treturn isEqualOnCurrentInfo ? isEqualOnCurrentInfo : player.accountId === accountId;\n\t\t});\n\t\treturn participantIdentityDto;\n\t}\n\n\t/**\n\t * @param {MatchDto} matchDto\n\t * @param {number} championId\n\t * @returns {ParticipantDto[] || CurrentGameParticipant[] }\n\t * Array with ParticipantDto if the given match is from match endpoint,\n\t * CurrentGameParticipant if it's from spectator endpoint.\n\t * For ranked matches the array will contain only a single element,\n\t * for non-ranked matches there can be more then one Players with the given champion.\n\t */\n\tstatic getParticipantsByChampion (matchDto, championId) {\n\t\tconst participants = matchDto.participants;\n\t\treturn participants.filter(participant => {\n\t\t\treturn participant.championId === championId;\n\t\t});\n\t}\n\n}\nmodule.exports = MatchUtil;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/util/MatchUtil.js	(revision 8d6a9176df997fb9bd64f6c18ba5b3c6b28a521a)
+++ lib/util/MatchUtil.js	(revision )
@@ -1,4 +1,5 @@
 const ErrorUtil = require('./ErrorUtil');
+
 class MatchUtil {
 	/**
 	 *
@@ -29,7 +30,7 @@
 	static getPatchFromGameVersion(gameVersion) {
 		const numDots = (gameVersion.match(/\./g) || []).length;
 
-		if (numDots === 1){
+		if (numDots === 1) {
 			// already major.minor
 			return gameVersion;
 		} else {
@@ -64,7 +65,7 @@
 	 * @param param.matchDto
 	 * @return {ParticipantIdentityDto | undefined} undefined if participant could not be found
 	 */
-	static getParticipantIdentityByAccountAndPlatformId({ matchDto, accountId, platformId}){
+	static getParticipantIdentityByAccountAndPlatformId({matchDto, accountId, platformId}) {
 		ErrorUtil.throwIfNotObject(matchDto, 'matchDto');
 		ErrorUtil.throwIfNotNumerical(accountId, 'accountId');
 		ErrorUtil.throwIfNotString(platformId, 'platformId');
@@ -86,12 +87,18 @@
 	 * For ranked matches the array will contain only a single element,
 	 * for non-ranked matches there can be more then one Players with the given champion.
 	 */
-	static getParticipantsByChampion (matchDto, championId) {
+	static getParticipantsByChampion(matchDto, championId) {
 		const participants = matchDto.participants;
 		return participants.filter(participant => {
 			return participant.championId === championId;
 		});
 	}
 
+	static validateMatchListParameters({queue, beginTime, endTime, beginIndex, endIndex, season, champion}) {
+
+
+	}
+
 }
-module.exports = MatchUtil;
\ No newline at end of file
+
+module.exports = MatchUtil;
Index: lib/endpoints/MatchEndpoint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const Bluebird = require('bluebird');\n\nconst Endpoint = require('../Endpoint');\n\nconst util = require('../util');\nconst {ErrorUtil, ParameterUtil, RegionAndPlatformUtil, MatchUtil} = util;\nconst ParameterError = require('../errors/ParameterError');\n\n/***\n * Endpoint to receive information about finished Match\n */\nclass MatchEndpoint extends Endpoint {\n\n\tconstructor(config, rateLimiter) {\n\t\tsuper('Match', config, rateLimiter);\n\t\tthis.apiUrl += `/match/${this.apiVersion}`;\n\t}\n\n\t/**\n\t * Get match by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @param options\n\t * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.\n\t * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {\n\t\tconst {forAccountId, forPlatformId} = options;\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => {\n\t\t\t\tErrorUtil.throwIfNotNumerical(gameId, 'gameId');\n\t\t\t\tif (forAccountId && !forPlatformId){\n\t\t\t\t\tthrow new ParameterError('\"forPlatformId\" has to be provided if \"forAccountId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forPlatformId && !forAccountId){\n\t\t\t\t\tthrow new ParameterError('\"forAccountId\" has to be provided if \"forPlatformId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');\n\t\t\t\t\tif (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){\n\t\t\t\t\t\tthrow new ParameterError(`\"forPlatformId\" is not a valid platformId. Received: ${forPlatformId}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))\n\t\t\t.then(matchDto => {\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tconst participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});\n\t\t\t\t\tmatchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];\n\t\t\t\t}\n\t\t\t\treturn matchDto;\n\t\t\t});\n\t}\n\n\t/**\n\t * Get match timeline by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchTimelineDto>}\n\t */\n\tgettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))\n\t\t\t.then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get matchlist for ranked games played on given account ID and platform ID\n\t * and filtered using given filter parameters, if any.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t *\n\t * @param options\n\t * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.\n\t * @param options.season {number[]} Set of season IDs for which to filtering matchlist.\n\t * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.\n\t * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.\n\t * @param options.endIndex {number} The end index to use for filtering matchlist.\n\t *\n\t * @return {Bluebird<MatchlistDto>}\n\t */\n\tgettingListByAccount(accountId, platformIdOrRegion, options = {}) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));\n\t}\n\n\t/**\n\t * Get matchlist for last 20 matches played on given account ID and platform ID.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchlistDto>}\n\t * @deprecated Will be removed in next major release, use gettingListByAccount instead.\n\t * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}\n\t */\n\tgettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});\n\t}\n\n\t/**\n\t * Get match IDs by tournament code.\n\t * NOTE: API-key needs to be a tournament API-KEY\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<number[]>}\n\t */\n\tgettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))\n\t\t\t.then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get match by match ID and tournament code.\n\t * @param gameId\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))\n\t\t\t.then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n}\n\nmodule.exports = MatchEndpoint;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/endpoints/MatchEndpoint.js	(revision 8d6a9176df997fb9bd64f6c18ba5b3c6b28a521a)
+++ lib/endpoints/MatchEndpoint.js	(revision )
@@ -30,15 +30,15 @@
 		return Bluebird.resolve()
 			.then(() => {
 				ErrorUtil.throwIfNotNumerical(gameId, 'gameId');
-				if (forAccountId && !forPlatformId){
+				if (forAccountId && !forPlatformId) {
 					throw new ParameterError('"forPlatformId" has to be provided if "forAccountId" is used');
 				}
-				if (forPlatformId && !forAccountId){
+				if (forPlatformId && !forAccountId) {
 					throw new ParameterError('"forAccountId" has to be provided if "forPlatformId" is used');
 				}
-				if (forAccountId && forPlatformId){
+				if (forAccountId && forPlatformId) {
 					ErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');
-					if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){
+					if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)) {
 						throw new ParameterError(`"forPlatformId" is not a valid platformId. Received: ${forPlatformId}`);
 					}
 				}
@@ -46,8 +46,12 @@
 			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
 			.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))
 			.then(matchDto => {
-				if (forAccountId && forPlatformId){
-					const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});
+				if (forAccountId && forPlatformId) {
+					const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({
+						matchDto,
+						accountId: forAccountId,
+						platformId: forPlatformId
+					});
 					matchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];
 				}
 				return matchDto;
@@ -69,17 +73,54 @@
 	/**
 	 * Get matchlist for ranked games played on given account ID and platform ID
 	 * and filtered using given filter parameters, if any.
-	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
 	 *
-	 * @param options
-	 * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.
-	 * @param options.season {number[]} Set of season IDs for which to filtering matchlist.
-	 * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.
-	 * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.
-	 * @param options.endIndex {number} The end index to use for filtering matchlist.
+	 * Implementation Notes:
+	 * A number of optional parameters are provided for filtering.<br>
+	 * It is up to the caller to ensure that the combination of filter parameters provided is valid
+	 * for the requested account, otherwise, no matches may be returned.<br>
+	 * <ul>
+	 *         <li>If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100.</li>
+	 *         <li>If endIndex is specified, but not beginIndex, then beginIndex defaults to 0.</li>
+	 *         <li>If both are specified, then endIndex must be greater than beginIndex.</li>
+	 *         <li>The maximum range allowed is 100, otherwise a 400 error code is returned.</li>
+	 *         <li>If beginTime is specified, but not endTime, then these parameters are ignored.</li>
+	 *         <li>If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history.</li>
+	 *         <li>If both are specified, then endTime should be greater than beginTime.</li>
+	 *         <li>The maximum time range allowed is one week, otherwise a 400 error code is returned.</li>
+	 * </ul>
+	 *
+	 * @param {number} accountId
+	 * @param {string} [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+	 *
+	 * @param {object} options
+	 * @param {number[]} options.queue <strong>Set of queue IDs for which to filtering matchlist.</strong>
+	 * @param {number[]} options.season <strong>Set of season IDs for which to filtering matchlist.</strong>
+	 * @param {number[]} options.champion <strong>Set of champion IDs for which to filtering matchlist.</strong>
+	 *
+	 * @param {number} options.beginTime <strong>The begin time to use for filtering matchlist specified as epoch milliseconds.</strong><br>
+	 * If beginTime is specified, but not endTime, then these parameters are ignored.
+	 * If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history.
+	 * If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week,
+	 * otherwise a 400 error code is returned.
+	 *
+	 * @param {number} options.endTime <strong>The end time to use for filtering matchlist specified as epoch milliseconds.</strong><br>
+	 * If beginTime is specified, but not endTime, then these parameters are ignored. If endTime is specified,
+	 * but not beginTime, then beginTime defaults to the start of the account's match history. If both are specified,
+	 * then endTime should be greater than beginTime. The maximum time range allowed is one week,
+	 * otherwise a 400 error code is returned.
+	 *
+	 * @param {number} options.beginIndex <strong>The begin index to use for filtering matchlist.</strong><br>
+	 * If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100.
+	 * If endIndex is specified, but not beginIndex, then beginIndex defaults to 0.
+	 * If both are specified, then endIndex must be greater than beginIndex.
+	 * The maximum range allowed is 100, otherwise a 400 error code is returned.
+	 *
+	 * @param {number} options.endIndex <strong>The end index to use for filtering matchlist.</strong><br>
+	 * If beginIndex is specified, but not endIndex,
+	 * then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex,
+	 * then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex.
+	 * The maximum range allowed is 100, otherwise a 400 error code is returned.
+	 *
 	 *
 	 * @return {Bluebird<MatchlistDto>}
 	 */
@@ -90,10 +131,31 @@
 			.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
 	}
 
+	/**
+	 * Get matchlist for ranked games played on given account ID and platform ID
+	 * and filtered using given filter parameters, if any.
+	 *
+	 * Resolves the pagination and return the combined results from given filters.
+	 * NOTE OCT 08 2017 - currently totalGames property is bugged, therefore pagination will be resolved synchronously.
+	 * When totalGames is fixed on the API pages will be resolved asynchronously for faster response.
+	 *
+	 * @see {@link gettingListByAccount}
+	 * @param accountId @see {@link gettingListByAccount}
+	 * @param platformIdOrRegion @see {@link gettingListByAccount}
+	 * @param options @see {@link gettingListByAccount}
+	 */
+	gettingListByAccountWithoutPagination(accountId, platformIdOrRegion, options = {}) {
+		return Bluebird.resolve()
+			.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))
+			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
+			.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
+	}
+
 	/**
 	 * Get matchlist for last 20 matches played on given account ID and platform ID.
 	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from
+	 * default-config.
 	 * @return {Bluebird<MatchlistDto>}
 	 * @deprecated Will be removed in next major release, use gettingListByAccount instead.
 	 * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}
