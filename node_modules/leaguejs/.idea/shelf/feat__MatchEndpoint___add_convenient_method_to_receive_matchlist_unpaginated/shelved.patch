Index: lib/endpoints/MatchEndpoint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const Bluebird = require('bluebird');\n\nconst Endpoint = require('../Endpoint');\n\nconst util = require('../util');\nconst {ErrorUtil, ParameterUtil, RegionAndPlatformUtil, MatchUtil} = util;\nconst ParameterError = require('../errors/ParameterError');\n\n/***\n * Endpoint to receive information about finished Match\n */\nclass MatchEndpoint extends Endpoint {\n\n\tconstructor(config, rateLimiter) {\n\t\tsuper('Match', config, rateLimiter);\n\t\tthis.apiUrl += `/match/${this.apiVersion}`;\n\t}\n\n\t/**\n\t * Get match by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @param options\n\t * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.\n\t * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {\n\t\tconst {forAccountId, forPlatformId} = options;\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => {\n\t\t\t\tErrorUtil.throwIfNotNumerical(gameId, 'gameId');\n\t\t\t\tif (forAccountId && !forPlatformId){\n\t\t\t\t\tthrow new ParameterError('\"forPlatformId\" has to be provided if \"forAccountId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forPlatformId && !forAccountId){\n\t\t\t\t\tthrow new ParameterError('\"forAccountId\" has to be provided if \"forPlatformId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');\n\t\t\t\t\tif (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){\n\t\t\t\t\t\tthrow new ParameterError(`\"forPlatformId\" is not a valid platformId. Received: ${forPlatformId}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))\n\t\t\t.then(matchDto => {\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tconst participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});\n\t\t\t\t\tmatchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];\n\t\t\t\t}\n\t\t\t\treturn matchDto;\n\t\t\t});\n\t}\n\n\t/**\n\t * Get match timeline by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchTimelineDto>}\n\t */\n\tgettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))\n\t\t\t.then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get matchlist for ranked games played on given account ID and platform ID\n\t * and filtered using given filter parameters, if any.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t *\n\t * @param options\n\t * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.\n\t * @param options.season {number[]} Set of season IDs for which to filtering matchlist.\n\t * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.\n\t * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.\n\t * @param options.endIndex {number} The end index to use for filtering matchlist.\n\t *\n\t * @return {Bluebird<MatchlistDto>}\n\t */\n\tgettingListByAccount(accountId, platformIdOrRegion, options = {}) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));\n\t}\n\n\t/**\n\t * Get matchlist for last 20 matches played on given account ID and platform ID.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchlistDto>}\n\t * @deprecated Will be removed in next major release, use gettingListByAccount instead.\n\t * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}\n\t */\n\tgettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});\n\t}\n\n\t/**\n\t * Get match IDs by tournament code.\n\t * NOTE: API-key needs to be a tournament API-KEY\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<number[]>}\n\t */\n\tgettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))\n\t\t\t.then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get match by match ID and tournament code.\n\t * @param gameId\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))\n\t\t\t.then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n}\n\nmodule.exports = MatchEndpoint;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/endpoints/MatchEndpoint.js	(date 1512386717000)
+++ lib/endpoints/MatchEndpoint.js	(revision )
@@ -11,122 +11,178 @@
  */
 class MatchEndpoint extends Endpoint {
 
-	constructor(config, rateLimiter) {
-		super('Match', config, rateLimiter);
-		this.apiUrl += `/match/${this.apiVersion}`;
-	}
+    constructor(config, rateLimiter) {
+        super('Match', config, rateLimiter);
+        this.apiUrl += `/match/${this.apiVersion}`;
+    }
 
-	/**
-	 * Get match by match ID
-	 * @param gameId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @param options
-	 * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.
-	 * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.
-	 * @return {Bluebird<MatchDto>}
-	 */
-	gettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {
-		const {forAccountId, forPlatformId} = options;
-		return Bluebird.resolve()
-			.then(() => {
-				ErrorUtil.throwIfNotNumerical(gameId, 'gameId');
-				if (forAccountId && !forPlatformId){
-					throw new ParameterError('"forPlatformId" has to be provided if "forAccountId" is used');
-				}
-				if (forPlatformId && !forAccountId){
-					throw new ParameterError('"forAccountId" has to be provided if "forPlatformId" is used');
-				}
-				if (forAccountId && forPlatformId){
-					ErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');
-					if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){
-						throw new ParameterError(`"forPlatformId" is not a valid platformId. Received: ${forPlatformId}`);
-					}
-				}
-			})
-			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
-			.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))
-			.then(matchDto => {
-				if (forAccountId && forPlatformId){
-					const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});
-					matchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];
-				}
-				return matchDto;
-			});
-	}
+    /**
+     * Get match by match ID
+     * @param gameId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @param options
+     * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.
+     * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.
+     * @return {Bluebird<MatchDto>}
+     */
+    gettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {
+        const {forAccountId, forPlatformId} = options;
+        return Bluebird.resolve()
+            .then(() => {
+                ErrorUtil.throwIfNotNumerical(gameId, 'gameId');
+                if (forAccountId && !forPlatformId) {
+                    throw new ParameterError('"forPlatformId" has to be provided if "forAccountId" is used');
+                }
+                if (forPlatformId && !forAccountId) {
+                    throw new ParameterError('"forAccountId" has to be provided if "forPlatformId" is used');
+                }
+                if (forAccountId && forPlatformId) {
+                    ErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');
+                    if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)) {
+                        throw new ParameterError(`"forPlatformId" is not a valid platformId. Received: ${forPlatformId}`);
+                    }
+                }
+            })
+            .then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
+            .then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))
+            .then(matchDto => {
+                if (forAccountId && forPlatformId) {
+                    const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({
+                        matchDto,
+                        accountId: forAccountId,
+                        platformId: forPlatformId
+                    });
+                    matchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];
+                }
+                return matchDto;
+            });
+    }
 
-	/**
-	 * Get match timeline by match ID
-	 * @param gameId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchTimelineDto>}
-	 */
-	gettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))
-			.then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));
-	}
+    /**
+     * Get match timeline by match ID
+     * @param gameId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchTimelineDto>}
+     */
+    gettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))
+            .then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));
+    }
 
-	/**
-	 * Get matchlist for ranked games played on given account ID and platform ID
-	 * and filtered using given filter parameters, if any.
-	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 *
-	 * @param options
-	 * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.
-	 * @param options.season {number[]} Set of season IDs for which to filtering matchlist.
-	 * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.
-	 * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.
-	 * @param options.endIndex {number} The end index to use for filtering matchlist.
-	 *
-	 * @return {Bluebird<MatchlistDto>}
-	 */
-	gettingListByAccount(accountId, platformIdOrRegion, options = {}) {
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))
-			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
-			.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
-	}
+    /**
+     * Get matchlist for ranked games played on given account ID and platform ID
+     * and filtered using given filter parameters, if any.
+     * @param accountId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     *
+     * @param options
+     * @param {number[]} options.queue Set of queue IDs for which to filtering matchlist.
+     * @param {number[]} options.season Set of season IDs for which to filtering matchlist.
+     * @param {number[]} options.champion Set of champion IDs for which to filtering matchlist.
+     * @param {number} options.beginTime The begin time to use for filtering matchlist specified as epoch milliseconds.
+     * @param {number} options.endTime The end time to use for filtering matchlist specified as epoch milliseconds.
+     * @param {number} options.beginIndex The begin index (skip value) to use for filtering matchlist.
+     * @param {number} options.endIndex The end index to use for filtering matchlist.
+     *
+     * @return {Bluebird<MatchlistDto>}
+     */
+    gettingListByAccount(accountId, platformIdOrRegion, options = {}) {
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))
+            .then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
+            .then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
+    }
 
-	/**
-	 * Get matchlist for last 20 matches played on given account ID and platform ID.
-	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchlistDto>}
-	 * @deprecated Will be removed in next major release, use gettingListByAccount instead.
-	 * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}
-	 */
-	gettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {
-		return this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});
-	}
+    /**
+     * Get matchlist for ranked games played on given account ID and platform ID
+     *
+     * end / startIndex can be bigger then the default 100.
+     * If no index is given, all pages available will be requested and returned.
+     * If only startIndex is given, all subsequent matchlist entries will be requested and returned.
+     * If only endIndex is given, all matchlist entries up to that index will be requested and returned
+     *
+     * and filtered using given filter parameters, if any.
+     * @param accountId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     *
+     * @param options
+     * @param {number[]} options.queue Set of queue IDs for which to filtering matchlist.
+     * @param {number[]} options.season Set of season IDs for which to filtering matchlist.
+     * @param {number[]} options.champion Set of champion IDs for which to filtering matchlist.
+     * @param {number} options.beginTime The begin time to use for filtering matchlist specified as epoch milliseconds.
+     * @param {number} options.endTime The end time to use for filtering matchlist specified as epoch milliseconds.
+     * @param {number} options.beginIndex The begin index (skip value) to use for filtering matchlist.
+     * @param {number} options.endIndex The end index to use for filtering matchlist.
+     *
+     * @return {Bluebird<MatchlistDto>}
+     */
+    gettingListByAccountUnpaginated(accountId, platformIdOrRegion, options = {}) {
+        const internalOptions = Object.assign({}, options);
+        internalOptions.beginIndex = !options.beginIndex ? 0 : options.beginIndex
+        // let endIndex = options.endIndex;
+
+        let result = [];
+
+        const loop = (index, matchListLength) => {
+            if (matchListLength === 100) {
+                return this.gettingListByAccount(accountId, platformIdOrRegion, options).then((matchListDto) => {
+                    internalOptions.beginIndex += 100;
+                    result = result.concat(matchListDto.matches);
+                    console.log('Matches from last call: ' + matchListDto.matches.length);
+                    console.log('Matches so far: ' + result.length);
+                    return loop(internalOptions.beginIndex, matchListDto.matches.length);
+                });
+            } else {
+                return Promise.resolve(result);
+            }
+        };
+
+        return loop(internalOptions.beginIndex, 100).then((result) => {
+            console.log('Done. Got ' + result.length + ' matchlist Entries');
+            return result;
+        });
+
+
+    }
+
+    /**
+     * Get matchlist for last 20 matches played on given account ID and platform ID.
+     * @param accountId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchlistDto>}
+     * @deprecated Will be removed in next major release, use gettingListByAccount instead.
+     * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}
+     */
+    gettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {
+        return this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});
+    }
 
-	/**
-	 * Get match IDs by tournament code.
-	 * NOTE: API-key needs to be a tournament API-KEY
-	 * @param tournamentCode
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<number[]>}
-	 */
-	gettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))
-			.then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
-	}
+    /**
+     * Get match IDs by tournament code.
+     * NOTE: API-key needs to be a tournament API-KEY
+     * @param tournamentCode
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<number[]>}
+     */
+    gettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))
+            .then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
+    }
 
-	/**
-	 * Get match by match ID and tournament code.
-	 * @param gameId
-	 * @param tournamentCode
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchDto>}
-	 */
-	gettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
-		return Bluebird.resolve()
-			.then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))
-			.then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
-	}
+    /**
+     * Get match by match ID and tournament code.
+     * @param gameId
+     * @param tournamentCode
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchDto>}
+     */
+    gettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
+        return Bluebird.resolve()
+            .then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))
+            .then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
+    }
 }
 
 module.exports = MatchEndpoint;
\ No newline at end of file
Index: test/endpoints/MatchEndpoint.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>describe('MatchEndpoint Testsuite', function () {\n\t'use strict';\n\n\tconst MatchEndpoint = require('../../lib/endpoints/MatchEndpoint');\n\n\tconst chai = require(\"chai\");\n\tconst chaiAsPromised = require(\"chai-as-promised\");\n\tconst should = chai.should;\n\tconst expect = chai.expect;\n\tchai.use(chaiAsPromised);\n\tchai.should();\n\n\tconst TestUtil = require('../TestUtil');\n\tlet mergedConfig = TestUtil.getTestConfig();\n\n\tconst mock_summoner = TestUtil.mocks.summoners.Colorfulstan;\n\n\n\tlet endpoint;\n\tbeforeEach(function () {\n\t\tlet {per10, per600, allowBursts} = mergedConfig.limits;\n\t\tendpoint = new MatchEndpoint(mergedConfig, TestUtil.createRateLimiter(per10, per600, allowBursts));\n\t});\n\n\tit('has its name added to default retryEndpoints', function () {\n\t\tendpoint.config.limits.retryEndpoints.should.include(endpoint.name);\n\t});\n\tdescribe('gettingById', function () {\n\t\tit('Using \"forAccountId\" it contains the player information for the provided accountID (and ONLY that)', function () {\n\t\t\treturn endpoint.gettingById(mock_summoner.gameId, mock_summoner.platformId, {forAccountId: mock_summoner.accountId, forPlatformId: mock_summoner.platformId})\n\t\t\t\t.then(matchDto => {\n\t\t\t\t\tlet numParticipantIdentityPlayers = 0;\n\t\t\t\t\tlet participantPlayer;\n\t\t\t\t\tmatchDto.participantIdentities.forEach(identity => {\n\t\t\t\t\t\tif (identity.player) {\n\t\t\t\t\t\t\tnumParticipantIdentityPlayers++;\n\t\t\t\t\t\t\tparticipantPlayer = identity.player;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\texpect(numParticipantIdentityPlayers).to.equal(1);\n\t\t\t\t\texpect(participantPlayer.accountId).to.equal(mock_summoner.accountId);\n\t\t\t\t});\n\t\t});\n\t\tit('can request a specific match for an accountId', function () {\n\t\t\treturn endpoint.gettingById(mock_summoner.gameId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('gameId');\n\t\t});\n\t});\n\tdescribe('gettingListByAccount', function () {\n\t\tit('can request the matchlist for an account', function () {\n\t\t\treturn endpoint.gettingListByAccount(mock_summoner.accountId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('matches')\n\t\t\t\t.an('Array')\n\t\t\t\t.with.length.of.at.least(100);\n\t\t});\n\t\tit('can request the matchlist for multiple summoners in parallel', function () {\n\t\t\tthis.timeout(0);\n\n\t\t\tconst accountIds = [\n\t\t\t\t24885403,\n\t\t\t\t42347345,\n\t\t\t\t21977757,\n\t\t\t\t33121340,\n\t\t\t\t31385891,\n\t\t\t\t28631306,\n\t\t\t\t22242237\n\t\t\t];\n\t\t\tconst platformId = 'euw1';\n\n\t\t\tfunction gettingFirstMatchFromMatchList(accountId, platformId){\n\t\t\t\t// console.log(accountId, platformId);\n\n\t\t\t\treturn endpoint.gettingListByAccount(accountId, platformId)\n\t\t\t\t\t.then(matchListDto => {\n\t\t\t\t\t\t// console.log(accountId, platformId);\n\t\t\t\t\t\t// console.log(matchListDto.matches[0]);\n\t\t\t\t\t\treturn endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Promise.all([\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[0], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[1], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[2], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[3], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[4], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[5], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[6], platformId)\n\t\t\t]).then(matchDtos => {\n\t\t\t\tmatchDtos.forEach((matchDto, index)=>{\n\t\t\t\t\t// console.log(accountIds[index], matchDto.participantIdentities.map(identity => identity.player));\n\t\t\t\t\tlet playerFound = matchDto.participantIdentities.find(identity => (identity.player.currentAccountId === accountIds[index] || identity.player.accountId === accountIds[index]));\n\t\t\t\t\texpect(playerFound).to.exist;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('gettingRecentListByAccount', function () {\n\t\tit('can request the most recent matches for an account', function () {\n\t\t\treturn endpoint.gettingRecentListByAccount(mock_summoner.accountId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('matches')\n\t\t\t\t.an('Array')\n\t\t\t\t.with.length.of.at.most(20);\n\t\t});\n\t});\n\tdescribe('gettingTimelineById', function () {\n\t\tit('can request the timeline for a given match', function () {\n\t\t\treturn endpoint.gettingTimelineById(mock_summoner.gameId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('frames');\n\t\t});\n\t});\n\tdescribe.skip('Tournament related', function () {\n\t\tdescribe('gettingIdsByTournament', function () { // TODO: get tournament api-key to test this\n\t\t\tit('can request the match ids for a tournament', function () {\n\t\t\t\t// return endpoint.gettingIdsByTournament(..., ...)\n\t\t\t\t// \t.should.eventually.be.an('Array');\n\t\t\t});\n\t\t});\n\t\tdescribe('gettingByIdForTournament', function () { // TODO: get tournament api-key to test this\n\t\t\tit('can request a match within a tournament', function () {\n\t\t\t\t// return endpoint.gettingIdsByTournament(..., ...)\n\t\t\t\t// \t.should.eventually.be.an('Array');\n\t\t\t});\n\t\t});\n\t});\n\n\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/endpoints/MatchEndpoint.test.js	(date 1512386717000)
+++ test/endpoints/MatchEndpoint.test.js	(revision )
@@ -51,7 +51,7 @@
 			return endpoint.gettingListByAccount(mock_summoner.accountId, mock_summoner.platformId)
 				.should.eventually.have.property('matches')
 				.an('Array')
-				.with.length.of.at.least(100);
+				.with.length(100);
 		});
 		it('can request the matchlist for multiple summoners in parallel', function () {
 			this.timeout(0);
@@ -77,6 +77,61 @@
 						return endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);
 					});
 			}
+
+			return Promise.all([
+				gettingFirstMatchFromMatchList(accountIds[0], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[1], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[2], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[3], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[4], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[5], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[6], platformId)
+			]).then(matchDtos => {
+				matchDtos.forEach((matchDto, index)=>{
+					// console.log(accountIds[index], matchDto.participantIdentities.map(identity => identity.player));
+					let playerFound = matchDto.participantIdentities.find(identity => (identity.player.currentAccountId === accountIds[index] || identity.player.accountId === accountIds[index]));
+					expect(playerFound).to.exist;
+				});
+			});
+		});
+	});
+	describe('gettingListByAccountUnpaginated', function () {
+		it('can request the matchlist for an account', function () {
+			return endpoint.gettingListByAccountUnpaginated(mock_summoner.accountId, mock_summoner.platformId)
+				.should.eventually.have.property('matches')
+				.an('Array')
+				.with.length(100);
+		});
+		it('can request the matchlist for multiple summoners in parallel', function () {
+			this.timeout(0);
+
+			const accountIds = [
+				24885403,
+				42347345,
+				21977757,
+				33121340,
+				31385891,
+				28631306,
+				22242237
+			];
+			const platformId = 'euw1';
+
+			function gettingFirstMatchFromMatchList(accountId, platformId){
+				// console.log(accountId, platformId);
+
+				return endpoint.gettingListByAccountUnpaginated(accountId, platformId)
+					.then(matchListDto => {
+						// console.log(accountId, platformId);
+						// console.log(matchListDto.matches[0]);
+						return endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);
+					});
+			}
 
 			return Promise.all([
 				gettingFirstMatchFromMatchList(accountIds[0], platformId)
