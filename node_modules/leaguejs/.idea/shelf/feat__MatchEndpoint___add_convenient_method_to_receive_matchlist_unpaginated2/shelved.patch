Index: lib/endpoints/MatchEndpoint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const Bluebird = require('bluebird');\n\nconst Endpoint = require('../Endpoint');\n\nconst util = require('../util');\nconst {ErrorUtil, ParameterUtil, RegionAndPlatformUtil, MatchUtil} = util;\nconst ParameterError = require('../errors/ParameterError');\n\n/***\n * Endpoint to receive information about finished Match\n */\nclass MatchEndpoint extends Endpoint {\n\n\tconstructor(config, rateLimiter) {\n\t\tsuper('Match', config, rateLimiter);\n\t\tthis.apiUrl += `/match/${this.apiVersion}`;\n\t}\n\n\t/**\n\t * Get match by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @param options\n\t * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.\n\t * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {\n\t\tconst {forAccountId, forPlatformId} = options;\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => {\n\t\t\t\tErrorUtil.throwIfNotNumerical(gameId, 'gameId');\n\t\t\t\tif (forAccountId && !forPlatformId){\n\t\t\t\t\tthrow new ParameterError('\"forPlatformId\" has to be provided if \"forAccountId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forPlatformId && !forAccountId){\n\t\t\t\t\tthrow new ParameterError('\"forAccountId\" has to be provided if \"forPlatformId\" is used');\n\t\t\t\t}\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');\n\t\t\t\t\tif (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){\n\t\t\t\t\t\tthrow new ParameterError(`\"forPlatformId\" is not a valid platformId. Received: ${forPlatformId}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))\n\t\t\t.then(matchDto => {\n\t\t\t\tif (forAccountId && forPlatformId){\n\t\t\t\t\tconst participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});\n\t\t\t\t\tmatchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];\n\t\t\t\t}\n\t\t\t\treturn matchDto;\n\t\t\t});\n\t}\n\n\t/**\n\t * Get match timeline by match ID\n\t * @param gameId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchTimelineDto>}\n\t */\n\tgettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))\n\t\t\t.then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get matchlist for ranked games played on given account ID and platform ID\n\t * and filtered using given filter parameters, if any.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t *\n\t * @param options\n\t * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.\n\t * @param options.season {number[]} Set of season IDs for which to filtering matchlist.\n\t * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.\n\t * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.\n\t * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.\n\t * @param options.endIndex {number} The end index to use for filtering matchlist.\n\t *\n\t * @return {Bluebird<MatchlistDto>}\n\t */\n\tgettingListByAccount(accountId, platformIdOrRegion, options = {}) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))\n\t\t\t.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))\n\t\t\t.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));\n\t}\n\n\t/**\n\t * Get matchlist for last 20 matches played on given account ID and platform ID.\n\t * @param accountId\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchlistDto>}\n\t * @deprecated Will be removed in next major release, use gettingListByAccount instead.\n\t * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}\n\t */\n\tgettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {\n\t\treturn this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});\n\t}\n\n\t/**\n\t * Get match IDs by tournament code.\n\t * NOTE: API-key needs to be a tournament API-KEY\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<number[]>}\n\t */\n\tgettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))\n\t\t\t.then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n\n\t/**\n\t * Get match by match ID and tournament code.\n\t * @param gameId\n\t * @param tournamentCode\n\t * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.\n\t * @return {Bluebird<MatchDto>}\n\t */\n\tgettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))\n\t\t\t.then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));\n\t}\n}\n\nmodule.exports = MatchEndpoint;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/endpoints/MatchEndpoint.js	(revision ca21f7ed4cf58bb05c241a4923af828e2876e149)
+++ lib/endpoints/MatchEndpoint.js	(revision )
@@ -11,122 +11,208 @@
  */
 class MatchEndpoint extends Endpoint {
 
-	constructor(config, rateLimiter) {
-		super('Match', config, rateLimiter);
-		this.apiUrl += `/match/${this.apiVersion}`;
-	}
+    constructor(config, rateLimiter) {
+        super('Match', config, rateLimiter);
+        this.apiUrl += `/match/${this.apiVersion}`;
+    }
 
-	/**
-	 * Get match by match ID
-	 * @param gameId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @param options
-	 * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.
-	 * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.
-	 * @return {Bluebird<MatchDto>}
-	 */
-	gettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {
-		const {forAccountId, forPlatformId} = options;
-		return Bluebird.resolve()
-			.then(() => {
-				ErrorUtil.throwIfNotNumerical(gameId, 'gameId');
-				if (forAccountId && !forPlatformId){
-					throw new ParameterError('"forPlatformId" has to be provided if "forAccountId" is used');
-				}
-				if (forPlatformId && !forAccountId){
-					throw new ParameterError('"forAccountId" has to be provided if "forPlatformId" is used');
-				}
-				if (forAccountId && forPlatformId){
-					ErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');
-					if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)){
-						throw new ParameterError(`"forPlatformId" is not a valid platformId. Received: ${forPlatformId}`);
-					}
-				}
-			})
-			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
-			.then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))
-			.then(matchDto => {
-				if (forAccountId && forPlatformId){
-					const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({matchDto, accountId: forAccountId, platformId: forPlatformId});
-					matchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];
-				}
-				return matchDto;
-			});
-	}
+    /**
+     * Get match by match ID
+     * @param gameId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @param options
+     * @param options.forAccountId If provided, used to identify the desired participant If Provided forPlatformId is also required.
+     * @param options.forPlatformId If provided, used to identify the desired participant. If Provided forAccountId is also required.
+     * @return {Bluebird<MatchDto>}
+     */
+    gettingById(gameId, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {
+        const {forAccountId, forPlatformId} = options;
+        return Bluebird.resolve()
+            .then(() => {
+                ErrorUtil.throwIfNotNumerical(gameId, 'gameId');
+                if (forAccountId && !forPlatformId) {
+                    throw new ParameterError('"forPlatformId" has to be provided if "forAccountId" is used');
+                }
+                if (forPlatformId && !forAccountId) {
+                    throw new ParameterError('"forAccountId" has to be provided if "forPlatformId" is used');
+                }
+                if (forAccountId && forPlatformId) {
+                    ErrorUtil.throwIfNotNumerical(forAccountId, 'forAccountId');
+                    if (!RegionAndPlatformUtil.validatePlatformId(forPlatformId)) {
+                        throw new ParameterError(`"forPlatformId" is not a valid platformId. Received: ${forPlatformId}`);
+                    }
+                }
+            })
+            .then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
+            .then(({_platformId, _options}) => this.executingRequest(`/matches/${gameId}`, _platformId, _options))
+            .then(matchDto => {
+                if (forAccountId && forPlatformId) {
+                    const participantIdentityDto = MatchUtil.getParticipantIdentityByAccountAndPlatformId({
+                        matchDto,
+                        accountId: forAccountId,
+                        platformId: forPlatformId
+                    });
+                    matchDto.participantIdentities = participantIdentityDto ? [participantIdentityDto] : [];
+                }
+                return matchDto;
+            });
+    }
 
-	/**
-	 * Get match timeline by match ID
-	 * @param gameId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchTimelineDto>}
-	 */
-	gettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))
-			.then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));
-	}
+    /**
+     * Get match timeline by match ID
+     * @param gameId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchTimelineDto>}
+     */
+    gettingTimelineById(gameId, platformIdOrRegion = this.config.PLATFORM_ID) {
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotNumerical(gameId, 'gameId'))
+            .then(() => this.executingRequest(`/timelines/by-match/${gameId}`, platformIdOrRegion));
+    }
 
-	/**
-	 * Get matchlist for ranked games played on given account ID and platform ID
-	 * and filtered using given filter parameters, if any.
-	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 *
-	 * @param options
-	 * @param options.queue {number[]} Set of queue IDs for which to filtering matchlist.
-	 * @param options.season {number[]} Set of season IDs for which to filtering matchlist.
-	 * @param options.champion {number[]} Set of champion IDs for which to filtering matchlist.
-	 * @param options.beginTime {number} The begin time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.endTime {number} The end time to use for filtering matchlist specified as epoch milliseconds.
-	 * @param options.beginIndex {number} The begin index (skip value) to use for filtering matchlist.
-	 * @param options.endIndex {number} The end index to use for filtering matchlist.
-	 *
-	 * @return {Bluebird<MatchlistDto>}
-	 */
-	gettingListByAccount(accountId, platformIdOrRegion, options = {}) {
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))
-			.then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
-			.then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
-	}
+    /**
+     * Get matchlist for games played on given account ID and platform ID
+     * and filtered using given filter parameters, if any.
+     *
+     * Implementation Notes:
+     * A number of optional parameters are provided for filtering.<br>
+     * It is up to the caller to ensure that the combination of filter parameters provided is valid
+     * for the requested account, otherwise, no matches may be returned.<br>
+     * <ul>
+     *         <li>If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100.</li>
+     *         <li>If endIndex is specified, but not beginIndex, then beginIndex defaults to 0.</li>
+     *         <li>If both are specified, then endIndex must be greater than beginIndex.</li>
+     *         <li>The maximum range allowed is 100, otherwise a 400 error code is returned.</li>
+     *         <li>If beginTime is specified, but not endTime, then these parameters are ignored.</li>
+     *         <li>If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history.</li>
+     *         <li>If both are specified, then endTime should be greater than beginTime.</li>
+     *         <li>The maximum time range allowed is one week, otherwise a 400 error code is returned.</li>
+     * </ul>
+     *
+     * @param {number} accountId
+     * @param {string} [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     *
+     * @param {object} options
+     * @param {number[]} options.queue <strong>Set of queue IDs for which to filtering matchlist.</strong>
+     * @param {number[]} options.season <strong>Set of season IDs for which to filtering matchlist.</strong>
+     * @param {number[]} options.champion <strong>Set of champion IDs for which to filtering matchlist.</strong>
+     *
+     * @param {number} options.beginTime <strong>The begin time to use for filtering matchlist specified as epoch milliseconds.</strong><br>
+     * If beginTime is specified, but not endTime, then these parameters are ignored.
+     * If endTime is specified, but not beginTime, then beginTime defaults to the start of the account's match history.
+     * If both are specified, then endTime should be greater than beginTime. The maximum time range allowed is one week,
+     * otherwise a 400 error code is returned.
+     *
+     * @param {number} options.endTime <strong>The end time to use for filtering matchlist specified as epoch milliseconds.</strong><br>
+     * If beginTime is specified, but not endTime, then these parameters are ignored. If endTime is specified,
+     * but not beginTime, then beginTime defaults to the start of the account's match history. If both are specified,
+     * then endTime should be greater than beginTime. The maximum time range allowed is one week,
+     * otherwise a 400 error code is returned.
+     *
+     * @param {number} options.beginIndex <strong>The begin index to use for filtering matchlist.</strong><br>
+     * If beginIndex is specified, but not endIndex, then endIndex defaults to beginIndex+100.
+     * If endIndex is specified, but not beginIndex, then beginIndex defaults to 0.
+     * If both are specified, then endIndex must be greater than beginIndex.
+     * The maximum range allowed is 100, otherwise a 400 error code is returned.
+     *
+     * @param {number} options.endIndex <strong>The end index to use for filtering matchlist.</strong><br>
+     * If beginIndex is specified, but not endIndex,
+     * then endIndex defaults to beginIndex+100. If endIndex is specified, but not beginIndex,
+     * then beginIndex defaults to 0. If both are specified, then endIndex must be greater than beginIndex.
+     * The maximum range allowed is 100, otherwise a 400 error code is returned.
+     *
+     *
+     * @return {Bluebird<MatchlistDto>}
+     */
+    gettingListByAccount(accountId, platformIdOrRegion, options = {}) {
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotNumerical(accountId, 'accountId'))
+            .then(() => ParameterUtil.extractPlatformIdAndOptions(platformIdOrRegion, options))
+            .then(({_platformId, _options}) => this.executingRequest(`/matchlists/by-account/${accountId}`, _platformId, _options));
+    }
 
-	/**
-	 * Get matchlist for last 20 matches played on given account ID and platform ID.
-	 * @param accountId
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchlistDto>}
-	 * @deprecated Will be removed in next major release, use gettingListByAccount instead.
-	 * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}
-	 */
-	gettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {
-		return this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});
-	}
+    /**
+     * Get matchlist for ranked games played on given account ID and platform ID
+     *
+     * end / startIndex can be bigger then the default 100.
+     * If no index is given, all pages available will be requested and returned.
+     * If only startIndex is given, all subsequent matchlist entries will be requested and returned.
+     * If only endIndex is given, all matchlist entries up to that index will be requested and returned
+     * @see {@link gettingListByAccount}
+     * @return {Bluebird<MatchlistDto>}
+     */
+    gettingListByAccountWithoutPagination(accountId, platformIdOrRegion, options = {}) {
+        const internalOptions = Object.assign({}, options);
+        internalOptions.beginIndex = !options.beginIndex ? 0 : options.beginIndex;
+        // let endIndex = options.endIndex || 100;
+
+        let matches = [];
+        let _matchListDTO;
+
+        const loop = (index, matchListLength) => {
+        	console.log(index, matchListLength)
+            if (matchListLength === 100 && (options.endIndex && index < options.endIndex)) {
+                return this.gettingListByAccount(accountId, platformIdOrRegion, internalOptions).then((matchListDto) => {
+                    internalOptions.beginIndex += 100;
+
+					if(!_matchListDTO){ _matchListDTO = matchListDto}
+
+					matches = matches.concat(matchListDto.matches);
+                    console.log('Matches from last call: ' + matchListDto.matches.length);
+                    console.log('Matches so far: ' + matches.length, matches[matches.length-1].gameId, matchListDto.matches[matchListDto.matches.length-1].gameId);
+                    return loop(internalOptions.beginIndex, matchListDto.matches.length);
+                });
+            } else {
+				_matchListDTO.matches = matches;
+                return Promise.resolve(_matchListDTO);
+            }
+        };
+
+        return loop(internalOptions.beginIndex, 100).then((result) => {
+            console.log('Done. Got ' + result.length + ' matchlist Entries');
+            return result;
+        });
+
+
+    }
+
+    /**
+     * Get matchlist for last 20 matches played on given account ID and platform ID.
+     * @param accountId
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchlistDto>}
+     * @deprecated Will be removed in next major release, use gettingListByAccount instead.
+     * {@link https://discussion.developer.riotgames.com/articles/3241/update-on-matchlist-and-recent-endpoints.html}
+     */
+    gettingRecentListByAccount(accountId, platformIdOrRegion = this.config.PLATFORM_ID) {
+        return this.gettingListByAccount(accountId, platformIdOrRegion, {beginIndex: 0, endIndex: 20});
+    }
 
-	/**
-	 * Get match IDs by tournament code.
-	 * NOTE: API-key needs to be a tournament API-KEY
-	 * @param tournamentCode
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<number[]>}
-	 */
-	gettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
-		return Bluebird.resolve()
-			.then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))
-			.then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
-	}
+    /**
+     * Get match IDs by tournament code.
+     * NOTE: API-key needs to be a tournament API-KEY
+     * @param tournamentCode
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<number[]>}
+     */
+    gettingIdsByTournament(tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
+        return Bluebird.resolve()
+            .then(() => ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode'))
+            .then(() => this.executingRequest(`/matches/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
+    }
 
-	/**
-	 * Get match by match ID and tournament code.
-	 * @param gameId
-	 * @param tournamentCode
-	 * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
-	 * @return {Bluebird<MatchDto>}
-	 */
-	gettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
-		return Bluebird.resolve()
-			.then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))
-			.then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
-	}
+    /**
+     * Get match by match ID and tournament code.
+     * @param gameId
+     * @param tournamentCode
+     * @param [platformIdOrRegion] case-insensitive. defaults to PLATFORM_ID set at instantiation of LeagueJs or from default-config.
+     * @return {Bluebird<MatchDto>}
+     */
+    gettingByIdForTournament(gameId, tournamentCode, platformIdOrRegion = this.config.PLATFORM_ID) { // TODO: unit tests!?
+        return Bluebird.resolve()
+            .then(() => Bluebird.all([ErrorUtil.throwIfNotNumerical(gameId, 'gameId'), ErrorUtil.throwIfNotString(tournamentCode, 'tournamentCode')]))
+            .then(() => this.executingRequest(`/matches/${gameId}/by-tournament-code/${tournamentCode}`, platformIdOrRegion));
+    }
 }
 
 module.exports = MatchEndpoint;
\ No newline at end of file
Index: lib/Endpoint.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>const Bluebird = require('bluebird');\n\nconst ApiRequest = require('./ApiRequest');\n\nconst util = require('./util');\nconst {EndpointUtil, ErrorUtil, RegionAndPlatformUtil} = util;\n\nconst ParameterError = require('./errors/ParameterError');\n\n/**\n * Riot API Endpoint\n */\nclass Endpoint {\n\n\t/**\n\t * Create new Endpoint based on Config\n\t */\n\tconstructor(name, config, rateLimiter) {\n\t\tif (arguments.length < 3) {\n\t\t\tthrow new ParameterError('Endpoint expects 3 mandatory Parameter: ' +\n\t\t\t\t'mandatory: (name: string, config: JSON, rateLimiter: RiotRateLimiter)');\n\t\t}\n\t\tthis.name = name;\n\n\t\t// cloning config to have independent Options per Endpoint!\n\t\tthis.config = Object.assign({}, config);\n\n\t\tErrorUtil.throwIfNotRateLimiter(rateLimiter, 'rateLimiter');\n\t\tthis.rateLimiter = rateLimiter;\n\n\t\tthis.apiVersion = this.config.API_VERSION;\n\t\t// NOTE: will be amended by implementing Endpoints\n\t\tthis.apiUrl = `https://{platformId}.${this.config.API_HOST}/lol`;\n\t\tthis.requestOptions = {token: this.config.API_KEY, rateLimiter: this.rateLimiter};\n\t\tif (this.config.limits.retryEndpoints.indexOf(this.name) !== -1) {\n\t\t\tthis.requestOptions.numRetriesLeft = this.config.limits.numMaxRetries;\n\t\t\tthis.requestOptions.intervalRetryMS = this.config.limits.intervalRetryMS;\n\t\t}\n\n\t\tif (this.config.caching.isEnabled) {this.setCache(this.config.caching.defaults);}\n\n\t}\n\n\tgetConfig() {\n\t\treturn this.config;\n\t}\n\n\tenableCaching(options = this.config.caching.defaults, Constructor = this.config.caching.constructor) {\n\t\tthis.config.caching.isEnabled = true;\n\t\tthis.setCache(options, Constructor);\n\t}\n\n\tdisableCaching() {\n\t\tthis.config.caching.isEnabled = false;\n\t}\n\n\tsetCache(options, Constructor = this.config.caching.constructor) {\n\t\tif (!options) {\n\t\t\tthrow new Error('options are required to set a new cache');\n\t\t}\n\t\tthis.config.caching.constructor = Constructor;\n\t\tthis.cache = new Constructor(options);\n\t}\n\n\tflushCache() {\n\t\tif(this.cache) {this.cache.flushAll();}\n\t}\n\n\t/**\n\t *\n\t * @private\n\t * @param endpointUrl the alternating url component for the respective endpoint\n\t * @param platformId\n\t * @param {object} options options to be included as query-string\n\t * @returns {string} request url\n\t */\n\t_buildURL(endpointUrl, platformId = this.config.PLATFORM_ID, options = {}) {\n\t\tconst query = EndpointUtil.buildQueryStringFromOptions(options);\n\t\treturn `${this.apiUrl.replace(/\\{platformId\\}/, platformId)}${endpointUrl}?${query}`;\n\t}\n\n\t/**\n\t * Execute a APIRequest based on the Config of this Endpoint\n\t * This request will be rate limited IF a ratelimiter is set for this endpoint.\n\t * if there is a Cached version of the request it will be used instead of making a request against the server\n\t *\n\t */\n\texecutingRequest(endpointUrl, platformIdOrRegion = this.config.PLATFORM_ID, options = {}) {\n\t\treturn Bluebird.resolve()\n\t\t\t.then(() => {\n\t\t\t\tconst platformId = RegionAndPlatformUtil.getPlatformIdFromPlatformIdOrRegion(platformIdOrRegion);\n\n\t\t\t\tconst requestUrl = this._buildURL(endpointUrl, platformId, options);\n\t\t\t\tconst cacheValue = this.cache ? this.cache.get(requestUrl) : null;\n\n\t\t\t\tif (cacheValue) {\n\t\t\t\t\treturn cacheValue;\n\t\t\t\t} else {\n\t\t\t\t\treturn ApiRequest.executing(requestUrl, this.requestOptions)\n\t\t\t\t\t\t.then(response => {\n\t\t\t\t\t\t\tif (this.cache) {this.cache.set(requestUrl, response);}\n\t\t\t\t\t\t\treturn response;\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n\nmodule.exports = Endpoint;
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lib/Endpoint.js	(revision ca21f7ed4cf58bb05c241a4923af828e2876e149)
+++ lib/Endpoint.js	(revision )
@@ -96,6 +96,8 @@
 				if (cacheValue) {
 					return cacheValue;
 				} else {
+					console.log(requestUrl)
+
 					return ApiRequest.executing(requestUrl, this.requestOptions)
 						.then(response => {
 							if (this.cache) {this.cache.set(requestUrl, response);}
Index: test/endpoints/MatchEndpoint.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>describe('MatchEndpoint Testsuite', function () {\n\t'use strict';\n\n\tconst MatchEndpoint = require('../../lib/endpoints/MatchEndpoint');\n\n\tconst chai = require(\"chai\");\n\tconst chaiAsPromised = require(\"chai-as-promised\");\n\tconst should = chai.should;\n\tconst expect = chai.expect;\n\tchai.use(chaiAsPromised);\n\tchai.should();\n\n\tconst TestUtil = require('../TestUtil');\n\tlet mergedConfig = TestUtil.getTestConfig();\n\n\tconst mock_summoner = TestUtil.mocks.summoners.Colorfulstan;\n\n\n\tlet endpoint;\n\tbeforeEach(function () {\n\t\tlet {per10, per600, allowBursts} = mergedConfig.limits;\n\t\tendpoint = new MatchEndpoint(mergedConfig, TestUtil.createRateLimiter(per10, per600, allowBursts));\n\t});\n\n\tit('has its name added to default retryEndpoints', function () {\n\t\tendpoint.config.limits.retryEndpoints.should.include(endpoint.name);\n\t});\n\tdescribe('gettingById', function () {\n\t\tit('Using \"forAccountId\" it contains the player information for the provided accountID (and ONLY that)', function () {\n\t\t\treturn endpoint.gettingById(mock_summoner.gameId, mock_summoner.platformId, {forAccountId: mock_summoner.accountId, forPlatformId: mock_summoner.platformId})\n\t\t\t\t.then(matchDto => {\n\t\t\t\t\tlet numParticipantIdentityPlayers = 0;\n\t\t\t\t\tlet participantPlayer;\n\t\t\t\t\tmatchDto.participantIdentities.forEach(identity => {\n\t\t\t\t\t\tif (identity.player) {\n\t\t\t\t\t\t\tnumParticipantIdentityPlayers++;\n\t\t\t\t\t\t\tparticipantPlayer = identity.player;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\texpect(numParticipantIdentityPlayers).to.equal(1);\n\t\t\t\t\texpect(participantPlayer.accountId).to.equal(mock_summoner.accountId);\n\t\t\t\t});\n\t\t});\n\t\tit('can request a specific match for an accountId', function () {\n\t\t\treturn endpoint.gettingById(mock_summoner.gameId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('gameId');\n\t\t});\n\t});\n\tdescribe('gettingListByAccount', function () {\n\t\tit('can request the matchlist for an account', function () {\n\t\t\treturn endpoint.gettingListByAccount(mock_summoner.accountId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('matches')\n\t\t\t\t.an('Array')\n\t\t\t\t.with.length.of.at.least(100);\n\t\t});\n\t\tit('can request the matchlist for multiple summoners in parallel', function () {\n\t\t\tthis.timeout(0);\n\n\t\t\tconst accountIds = [\n\t\t\t\t24885403,\n\t\t\t\t42347345,\n\t\t\t\t21977757,\n\t\t\t\t33121340,\n\t\t\t\t31385891,\n\t\t\t\t28631306,\n\t\t\t\t22242237\n\t\t\t];\n\t\t\tconst platformId = 'euw1';\n\n\t\t\tfunction gettingFirstMatchFromMatchList(accountId, platformId){\n\t\t\t\t// console.log(accountId, platformId);\n\n\t\t\t\treturn endpoint.gettingListByAccount(accountId, platformId)\n\t\t\t\t\t.then(matchListDto => {\n\t\t\t\t\t\t// console.log(accountId, platformId);\n\t\t\t\t\t\t// console.log(matchListDto.matches[0]);\n\t\t\t\t\t\treturn endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn Promise.all([\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[0], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[1], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[2], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[3], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[4], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[5], platformId)\n\t\t\t\t,\n\t\t\t\tgettingFirstMatchFromMatchList(accountIds[6], platformId)\n\t\t\t]).then(matchDtos => {\n\t\t\t\tmatchDtos.forEach((matchDto, index)=>{\n\t\t\t\t\t// console.log(accountIds[index], matchDto.participantIdentities.map(identity => identity.player));\n\t\t\t\t\tlet playerFound = matchDto.participantIdentities.find(identity => (identity.player.currentAccountId === accountIds[index] || identity.player.accountId === accountIds[index]));\n\t\t\t\t\texpect(playerFound).to.exist;\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\tdescribe('gettingRecentListByAccount', function () {\n\t\tit('can request the most recent matches for an account', function () {\n\t\t\treturn endpoint.gettingRecentListByAccount(mock_summoner.accountId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('matches')\n\t\t\t\t.an('Array')\n\t\t\t\t.with.length.of.at.most(20);\n\t\t});\n\t});\n\tdescribe('gettingTimelineById', function () {\n\t\tit('can request the timeline for a given match', function () {\n\t\t\treturn endpoint.gettingTimelineById(mock_summoner.gameId, mock_summoner.platformId)\n\t\t\t\t.should.eventually.have.property('frames');\n\t\t});\n\t});\n\tdescribe.skip('Tournament related', function () {\n\t\tdescribe('gettingIdsByTournament', function () { // TODO: get tournament api-key to test this\n\t\t\tit('can request the match ids for a tournament', function () {\n\t\t\t\t// return endpoint.gettingIdsByTournament(..., ...)\n\t\t\t\t// \t.should.eventually.be.an('Array');\n\t\t\t});\n\t\t});\n\t\tdescribe('gettingByIdForTournament', function () { // TODO: get tournament api-key to test this\n\t\t\tit('can request a match within a tournament', function () {\n\t\t\t\t// return endpoint.gettingIdsByTournament(..., ...)\n\t\t\t\t// \t.should.eventually.be.an('Array');\n\t\t\t});\n\t\t});\n\t});\n\n\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- test/endpoints/MatchEndpoint.test.js	(revision ca21f7ed4cf58bb05c241a4923af828e2876e149)
+++ test/endpoints/MatchEndpoint.test.js	(revision )
@@ -51,7 +51,7 @@
 			return endpoint.gettingListByAccount(mock_summoner.accountId, mock_summoner.platformId)
 				.should.eventually.have.property('matches')
 				.an('Array')
-				.with.length.of.at.least(100);
+				.with.length(100);
 		});
 		it('can request the matchlist for multiple summoners in parallel', function () {
 			this.timeout(0);
@@ -77,6 +77,79 @@
 						return endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);
 					});
 			}
+
+			return Promise.all([
+				gettingFirstMatchFromMatchList(accountIds[0], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[1], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[2], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[3], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[4], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[5], platformId)
+				,
+				gettingFirstMatchFromMatchList(accountIds[6], platformId)
+			]).then(matchDtos => {
+				matchDtos.forEach((matchDto, index)=>{
+					// console.log(accountIds[index], matchDto.participantIdentities.map(identity => identity.player));
+					let playerFound = matchDto.participantIdentities.find(identity => (identity.player.currentAccountId === accountIds[index] || identity.player.accountId === accountIds[index]));
+					expect(playerFound).to.exist;
+				});
+			});
+		});
+	});
+	describe('gettingListByAccountWithoutPagination', function () {
+		it.skip('can request the matchlist for an account', function () {
+			return endpoint.gettingListByAccountWithoutPagination(mock_summoner.accountId, mock_summoner.platformId)
+				.should.eventually.have.property('matches')
+				.an('Array')
+				.with.length(100);
+		});
+		it('can request less then 100 matches', function () {
+			return endpoint.gettingListByAccountWithoutPagination(mock_summoner.accountId, mock_summoner.platformId, {endIndex:10})
+				.should.eventually.have.property('matches')
+				.an('Array')
+				.with.length(10);
+		});
+		it('can request exactly 100 matches', function () {
+			return endpoint.gettingListByAccountWithoutPagination(mock_summoner.accountId, mock_summoner.platformId, {beginIndex:53, endIndex:153})
+				.should.eventually.have.property('matches')
+				.an('Array')
+				.with.length(100);
+		});
+		it('can request more then 100 matches', function () {
+			return endpoint.gettingListByAccountWithoutPagination(mock_summoner.accountId, mock_summoner.platformId, {beginIndex:132, endIndex:453})
+				.should.eventually.have.property('matches')
+				.an('Array')
+				.with.length(453-132);
+		});
+		it.skip('can request the matchlist for multiple summoners in parallel', function () {
+			this.timeout(0);
+
+			const accountIds = [
+				24885403,
+				42347345,
+				21977757,
+				33121340,
+				31385891,
+				28631306,
+				22242237
+			];
+			const platformId = 'euw1';
+
+			function gettingFirstMatchFromMatchList(accountId, platformId){
+				// console.log(accountId, platformId);
+
+				return endpoint.gettingListByAccountWithoutPagination(accountId, platformId, {endIndex:1})
+					.then(matchListDto => {
+						// console.log(accountId, platformId);
+						// console.log(matchListDto.matches[0]);
+						return endpoint.gettingById(matchListDto.matches[0].gameId, matchListDto.matches[0].platformId);
+					});
+			}
 
 			return Promise.all([
 				gettingFirstMatchFromMatchList(accountIds[0], platformId)
